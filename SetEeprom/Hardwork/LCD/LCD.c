#include "LCD.h"

void Setlie(void);
void Delay(vu32 nCount)
{
    for(; nCount != 0; nCount--);
}


void LCD_Init(void)
{
	//u16 i,j,x;
  GPIO_InitTypeDef GPIO_InitStructure;
	
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB|
	                      RCC_AHBPeriph_GPIOD|
	                      RCC_AHBPeriph_GPIOC, ENABLE);

	//CS,RES
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_11|GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_UP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	
	GPIO_Init(GPIOC,&GPIO_InitStructure);
	GPIO_SetBits(GPIOC,GPIO_Pin_11);
	GPIO_SetBits(GPIOC,GPIO_Pin_12);
	
  //WR,RD,A0(RS),BACK
  GPIO_InitStructure.GPIO_Pin=GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_8;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
	
	GPIO_SetBits(GPIOB,GPIO_Pin_3);
	GPIO_SetBits(GPIOB,GPIO_Pin_4);
	GPIO_SetBits(GPIOB,GPIO_Pin_5);
	GPIO_SetBits(GPIOB,GPIO_Pin_8);

	//DATA
  GPIO_InitStructure.GPIO_Pin=GPIO_Pin_All;
	GPIO_Init(GPIOD,&GPIO_InitStructure);

	RES_1;
	Delay(5);
	RES_0;
	Delay(50);
	RES_1;
	Delay(5);
	
	LCD_WriteCmd(0xe2);//软件复位
	LCD_WriteCmd(0x2c);//升压步骤1
	LCD_WriteCmd(0x2e);//升压步骤2
	LCD_WriteCmd(0x2f);//升压步骤3
	LCD_WriteCmd(0x25);//粗调对比度
	LCD_WriteCmd(0x81);//细调指令
	LCD_WriteCmd(0x0f);//细调值，设置范围
	LCD_WriteCmd(0xa2);//1/9偏压比
	LCD_WriteCmd(0xc0);//行扫描顺序：0xc0正向扫描,0xc8反向扫描 
	LCD_WriteCmd(0xa1);//列扫描顺序：0xa0为Segment正向,0xa1 为Segment反向
	LCD_WriteCmd(0x60);//起始行：第一行
	LCD_WriteCmd(0xaf); //打开显示，0xaf显示器开,0xae显示器关 

	clrscr();//清屏
}


void SetDataGPIO_In(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	//PD0,1,2,4,5,6,7
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|
	                            GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_PuPd= GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOD,&GPIO_InitStructure);
}

//设置GPIO为输出模式
void SetDataGPIO_Out(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	//PD0,1,2,4,5,6,7
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|
	                            GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_UP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOD,&GPIO_InitStructure);
}


//===========测忙================
void LCD_CheckBusy()
{ u8 signal;
 
 SetDataGPIO_In();
 RS_0;
 WR_1;
 do
 {
  RD_0;
  Delay(10);
  signal=GPIO_ReadInputData(GPIOD);
  Delay(10);
  RD_1;
 }while(signal&0x80);
 SetDataGPIO_Out();
  Delay(5);
}




void LCD_WriteCmd(u8 cmd)
{

  
  LCD_CheckBusy();
	
	CS_1;
  RS_1;
	WR_1;
	Delay(10);
	
	RS_0;
	CS_0;
	WR_0;

 GPIO_Write(GPIOD,cmd);
  Delay(100);
	
  WR_1;
	Delay(50);
  CS_1;
	Delay(5);

}


//void wdata80(unsigned char dat)
void LCD_WriteData(u8 dat)
{
  
  LCD_CheckBusy();
	
	CS_1;
  RS_1;
	WR_1;
	Delay(10);
	
	RS_1;
	CS_0;
	WR_0;

 GPIO_Write(GPIOD,dat);
  Delay(100);
	
  WR_1;
	Delay(50);
  CS_1;
	Delay(5);
}

extern void SoftwareDelay(uint32_t nCount);



void clrscr(void)//清屏
{
  int i,page;
  for(page=0;page<8;page++)
  {
   LCD_WriteCmd(0xB0|page);
   LCD_WriteCmd(0x10);
   LCD_WriteCmd(0x02);
    for(i=0;i<130;i++)
    {
		 LCD_WriteData(0);
		}
		
  }
}

u8 a[4][16]={
{0x10,0x04,0x60,0x04,0x02,0x7E,0x8C,0x01,0x00,0x40,0x00,0x7E,0xFE,0x42,0x92,0x42},
{0x92,0x7E,0x92,0x42,0x92,0x7E,0x92,0x42,0xFE,0x42,0x00,0x7E,0x00,0x40,0x00,0x00},/*"温",0*/
{0x00,0x40,0x00,0x30,0xFC,0x8F,0x24,0x80,0x24,0x84,0x24,0x4C,0xFC,0x55,0x25,0x25},
{0x26,0x25,0x24,0x25,0xFC,0x55,0x24,0x4C,0x24,0x80,0x24,0x80,0x04,0x80,0x00,0x00}/*"度",1*/
};

void Setlie(void)
{
  int i,page;
  for(page=0;page<2;page++)
  {
		  LCD_WriteCmd(0xB0|page);
      LCD_WriteCmd(0x10);	
      LCD_WriteCmd(0x03);
		if(0 == page)
		{
			for(i=0;i<32;i++)
				{
					LCD_WriteData(a[0][2*i]);
				}
	  }
	 	 
		if(1 == page)
		{
			for(i=0;i<32;i++)
				{
					LCD_WriteData(a[0][2*i+1]);
				}
	  }
  }
}

typedef struct 
{
    char Index[1];
    char Msk[16];
}typFNT_ASC16	;

const  typFNT_ASC16  ASC_16[] = 
{	
"1",0x00,0x00,0x08,0x08,0xFC,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x07,0x04,0x04,0x00,
"2",0x00,0x00,0x08,0x04,0x84,0x44,0x38,0x00,0x00,0x00,0x06,0x05,0x04,0x04,0x04,0x00,
"3",0x00,0x00,0x08,0x04,0x44,0x44,0xB8,0x00,0x00,0x00,0x02,0x04,0x04,0x04,0x03,0x00,
"4",0x00,0x00,0x80,0x60,0x18,0xFC,0x00,0x00,0x00,0x00,0x01,0x01,0x05,0x07,0x05,0x00,
"5",0x00,0x00,0x7C,0x44,0x44,0x44,0x84,0x00,0x00,0x00,0x02,0x04,0x04,0x04,0x03,0x00,
"6",0x00,0x00,0xF0,0x48,0x44,0x44,0x80,0x00,0x00,0x00,0x03,0x04,0x04,0x04,0x03,0x00,
"7",0x00,0x00,0x0C,0x04,0x84,0x64,0x1C,0x00,0x00,0x00,0x00,0x06,0x01,0x00,0x00,0x00,
"8",0x00,0x00,0xB8,0x44,0x44,0x44,0xB8,0x00,0x00,0x00,0x03,0x04,0x04,0x04,0x03,0x00,
"9",0x00,0x00,0x38,0x44,0x44,0x44,0xF8,0x00,0x00,0x00,0x00,0x04,0x04,0x02,0x01,0x00,
"0",0x00,0x00,0xF8,0x04,0x04,0x04,0xF8,0x00,0x00,0x00,0x03,0x04,0x04,0x04,0x03,0x00,
};
typedef struct	
{
	char Index[2];
	char Msk[32];
} typFNT_GB16;
const typFNT_GB16  GB_16[] = {

"系", 0x00,0x00,0x02,0x00,0x22,0x42,0x22,0x22,0x32,0x1A,0x2E,0x43,0xA2,0x82,0x62,0x7E,
      0x22,0x02,0x22,0x02,0x91,0x0A,0x09,0x13,0x01,0x66,0x00,0x00,0x00,0x00,0x00,0x00,

"统", 0x20,0x22,0x30,0x67,0xAC,0x22,0x63,0x12,0x30,0x92,0x88,0x40,0xC8,0x30,0xA8,0x0F,
      0x99,0x00,0x8E,0x00,0x88,0x3F,0xA8,0x40,0xCC,0x40,0x88,0x41,0x00,0x70,0x00,0x00,

"初", 0x10,0x02,0x10,0x01,0x91,0x00,0xD6,0xFF,0x30,0x01,0x98,0x82,0x00,0x40,0x08,0x20,
      0x08,0x18,0xF8,0x07,0x08,0x40,0x08,0x80,0x08,0x40,0xFC,0x3F,0x08,0x00,0x00,0x00,

"始", 0x10,0x40,0x10,0x22,0xF0,0x15,0x1F,0x08,0x10,0x16,0xF0,0x61,0x40,0x00,0x60,0xFE,
      0x58,0x42,0x47,0x42,0x40,0x42,0x40,0x42,0x50,0x42,0x60,0xFF,0xC0,0x02,0x00,0x00,

"化", 0x80,0x00,0x40,0x00,0x20,0x00,0xF8,0xFF,0x07,0x00,0x00,0x04,0x00,0x02,0x00,0x01,
      0xFF,0x3F,0x40,0x40,0x20,0x40,0x10,0x40,0x18,0x40,0x00,0x40,0x00,0x70,0x00,0x00,

"□", 0x00,0x00,0x00,0x00,0xFC,0x3F,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,
      0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0xFC,0x3F,0x00,0x00,0x00,0x00,

"■", 0x00,0x00,0x00,0x00,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,
      0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0x00,0x00,0x00,0x00
			

};
#define ASC_CHR_WIDTH	8
#define ASC_CHR_HEIGHT	12
#define ASC_HZ_WIDTH	16
//#define ASC_HZ_HEIGHT	12
void Setadd(u8 xl,u8 yl)
{    u8 i;
     xl+=4;
     i=(xl+0)&0x0f;
     xl=(xl>>4)+0x10;

    LCD_WriteCmd(0xb0+yl); 	  
	  LCD_WriteCmd(xl);
 	  LCD_WriteCmd(i);	
}
void disp_ch(unsigned char c,u8 uCol,u8 uPage)
{
	unsigned char k,j,ch_w;
	unsigned char width;
	unsigned char len;

	len=sizeof(ASC_16)/sizeof(ASC_16[0]);
	for(k=0;k<len;k++)
	{
		if(c == ASC_16[k].Index[0] ) break;
	}
	if(k<len)
	{
		
		if(c=='-'||c==':') 
			width=ASC_CHR_WIDTH-2;
		else if(c=='|')
			width=ASC_HZ_WIDTH-ASC_CHR_WIDTH;
		else 
			width=ASC_CHR_WIDTH;
		
		   Setadd(uCol,uPage);
			for(j=0;j<width;j++)
			{
				ch_w=ASC_16[k].Msk[j];				
				LCD_WriteData(ch_w); 
			}

			Setadd(uCol,uPage+1);
			for(j=0;j<width;j++)
			{
				ch_w=ASC_16[k].Msk[ASC_CHR_WIDTH+j];
				LCD_WriteData(ch_w); 
			}		
	}
}


void disp_hz(u8 *hz,u8 uCol,u8 uPage)
{
	unsigned char k,j,ch_w;

	for(k=0;k<sizeof(GB_16)/sizeof(GB_16[0]);k++)
	{
		if(hz[0] == GB_16[k].Index[0] && hz[1] == GB_16[k].Index[1])
			break;
	}

	
	for(j=0;j<ASC_HZ_WIDTH;j++)
	{		
		Setadd(uCol+j,uPage);
		ch_w=GB_16[k].Msk[2*j];
		LCD_WriteData(ch_w); 
		Setadd(uCol+j,uPage+1);
		ch_w=GB_16[k].Msk[2*j+1];
		LCD_WriteData(ch_w); 
	}

}



void disp_str(u8 *p,u8 uCol,u8 uPage)
{
	unsigned char i=0;
	while(p[i]>0)
	{
		if(p[i] < 128)
		{	
			disp_ch(p[i],uCol,uPage);
            uCol+=8;
		}
		else
		{	
			disp_hz(&p[i],uCol,uPage);
			uCol+=16;
			i++;
		}
		i++;
	}
}








